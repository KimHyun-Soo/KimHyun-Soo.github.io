---
title: "[백준] 알파벳"
categories: BOJ
tags: BOJ python dfs bfs
published: true
---

### [[백준] 알파벳](https://www.acmicpc.net/problem/1987)

---

### 풀이

이 문제는 문자열 그래프가 주어질 때 방문한 문자열에 없는 문자만을 골라서  
길을 따라갔을 때, 최대 길이를 구하는 문제이다.  
<br>
전형적인 bfs, dfs 문제라고 생각해서 dfs를 이용해서 풀었다.  
visit를 갖고 가면서 방문했을 때 넣어주고 조건문을 이용해 그 방문한 문자열들 안에 있다면 dfs에 넣지 않고 최대 값을 계속 생성해준다.  
<br>
문제는 ,, dfs를 이용해서 풀었더니 시간초과가 엄청 뜬다..  
시간이 없으니 다시 돌아와서 고민을 해봐야겠다. 왜 시간초과가 뜨는지.

```python

# dfs - 시간초과 에러
import sys
R, C = map(int, sys.stdin.readline().split())
graph = [list(sys.stdin.readline().rstrip()) for _ in range(R)]
dx = [0, 1, 0, -1]
dy = [1, 0, -1, 0]
answer = 1
visit = [graph[0][0]]
def dfs(x, y, graph, ans):
    global answer, dx, dy, visit
    answer = max(answer, ans)
    for i in range(4):
        mx, my = x + dx[i], y + dy[i]
        if 0 <= mx < len(graph) and 0 <= my < len(graph[0]) and graph[mx][my] not in visit:
            visit.append(graph[mx][my])
            dfs(mx, my, graph, ans+1)
            visit.remove(graph[mx][my])

def solution(R, C, graph):
    global answer
    dfs(0, 0, graph, 1)
    return answer

print(solution(R, C, graph))
```

---

### 실수 및 배운 점

- 많은 수열을 고려하면서 또 다른 예외가 있는 지 항상 찾자.

- 2차 dp 이용안해도 괜찮다, sum을 만들어 다른 저장소에 메모제이션 해줄 수 있다.

- 실수했던 것은 문제2)에서 n = 1일 경우, d = [0, 0] 이 만들어지는 데,  
  `d[0] = 1, d[1] = 2, d[3] = 7` 을 해서 error가 생겼다.  
  **인덱싱**은 '참조'를 해서 그 안에 집어 넣는 것이라는 걸 알게 되었다.  
  <br>
  대신 슬라이싱을 통해 어떤 값이 들어와도 list를 extend할 수 있게 만들어줬다.  
  **슬라이싱**은 indexing과 함께 extend도 할 수 있는 메소드라는 것을 알게 되었다.!!
